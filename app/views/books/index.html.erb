<div class="container">
  <div class="row">
  <h1>Ajax rendering, Forms in Single Page, Polymorphism</h1>
  </div>
</div>


<%= link_to 'Create Book', new_book_path %>
<br>
<%= link_to 'Create Author / Book', new_author_path %>

<div class="container">

<div class="row">
  <h3><a href="#cookie"> Form with no model in single page with a cookie</a>  </h3>
  </div>
  <div class="row">
  <h3><a href="#3-rendering"> Three rendering methods</a>  </h3>
  </div>

  <div class="row">
    <h3><a href="#search"> Ajax form single page search </a></h3>
  </div>

  <div class="row">
    <h3><a href="#API-JSON"> API call and JSON rendering </a></h3>
  </div>

</div>

<div class="container" id="cookie">
  <h5>Submitting a form with no model in this single page via a cookie (no JS)</h5>
  <p>The input of this form will be transmitted to this page via a cookie. This form is 'POST' by default, and controlled by a method
   'books#get_form' with a 'POST' route.
  The controller method saves the params in a cookie, just declared by naming it, for example 'cookies[:form]' here.
   Then the method 'redirect_to' this same page. There is a partial '_form.html.erb' bellow waiting for an input: %= render 'books/form'  % . Once submitted, the input appears bellow. 
  We can keep this persistant until the browser is closed, or destroy the cookie after serving the partial, so that
  a page refresh will reset the partial (this is the case here).</p>

  <%= simple_form_for :search, url: get_form_path do |f| %>   
    <%= f.input_field :input %>
    <%= f.submit "Display with Cookie", class:"btn btn-primary"%>
  <% end %>

  Result: <h6> <%= render 'books/form'  %></h6>
  <% cookies.delete :form %>
  <br>
  <h5>Submitting a form in this single page via AJAX.</h5>
  <div class="row">
    <div class="col">
    <%= simple_form_for :search, url: get_form_ajax_path, remote: true do |f| %>   
    <%= f.input_field :input, id:"input1" %> <!-- .input_field to put aligned -->
    <%= f.submit "Simple_form remote / AJAX", class:"btn btn-primary"%>

    <!-- Note: for a custom button, we do: -->
    <!--  <%= f.button :submit, 'Search!' do %> -->
    <!--            my custom button text           -->
    <!--      <% end %>                             -->
    
  <% end %>
    </div>
    <div class="col">
    <%= form_with url:'/get_form_ajax2' do |f| %>
    <%= f.text_field :input, id:"input2" %>
    <%= f.submit "'book/form_with'", class:"btn btn-primary"%>
  <% end %>
    </div>
  </div>
  
  <p>We specify the url to fetch the 'POST' method, and since we use 'remote:true' 
  with 'simple_form_for', and nothing with 'form_with' (it's remote: ture by default).
  It will call a Javascript function that will render an HTML
   string into the HTML attribute of a DOM element.</p>

  Result: <h6 id="ajax-form"></h6>
  <br>
  <h5> Submit 'POST' route with 'form-with'. </h5>
  
  

  
  </div>

<div class="row" id='3-rendering'>
  <div class="container">
    <h4>Three rendering methods: partials within a page, link_to another page, AJAX display in the page via a link</h4>
    <div class="row">
      
      <div class="col">
        <p>The HTTP request 'url = /books/index' displays the file '../views/index.html.erb' and the needed data is served by the
        controller/method  'books#index'. This column contains a 'render' declaration to display the partial 'views/_books_all.html.erb'.
         The data is furnished by the method 'books#index' so this column is loaded-displayed every time the index page is loaded.
          We precise how the variables furnished by the controller are passed to partials in this way :</p>
        <p> % render partial: 'books/books_all',  locals: {books: @books} %</p>
        <p> When clicking on the 'return' link, this reloads the whole page. Since the stars bellow are randomly
        set, they will change at each reload.</p>
        <p> The button bellow just toggles a CSS class '.not-active { display:none; }' to ON/OFF via Javascript function 'classListToggle('not-active').</p>

        <button class="btn btn-primary" id="hideBtn"> Hide / Show bellow all books </button>
        <!-- class .active defined in _alert.scss and class toggled by 'toggleDiv.js-->
        <div id="hideMe" > <!-- class="not-active" -->
          <%= render 'books/books_all', books: @books, cached: true %></div>
          <%#= render partial: 'books/books_all',  locals: {books: @books} %>
        </div>

      <div class="col">
        <p> The link bellow makes a HTTP request 'url= ../books_all' to display the file  '/views/books_all', which in served by the method 'books#books_all' for the data. </p>
        <p>% link_to 'View books in another page', books_all_path % </p>
        <p>This is a link to a new page. We pass directly the instance '@books' to the view which uses '@books'. This is different from partials, which use a local variable,
         'books: @books'.</p>
        <p> The same info is displayed, but through the copy of the partial without the _underscore, ie 'books/reviews_all.html.erb'. 
        This time, the data is furnished by the method books#reviews_all' which 'lazy' renders '../books/books_all.html' with Rails naming association convention. </p>

        <p><%= link_to "View 'books.json' in another page", books_display_json_path, class:'btn btn-primary' %> </p>
        <p> "render json: @books"</p>
      </div>

      <div class="col">
        <p>AJAX rendering on same page. The link:</p>
        <p>%= link_to 'All books with AJAX', books_ajax_path, remote: true %</p>
        calls the method 'books#books_ajax' which will respond with corresponding Javascript file '../views/books_all_ajax.js.erb', which will display the same partial
         'views/_books_all.html.erb'. The controller's method furnishes the data, and the JS function will ask to render the partial at a desingned location, given by setting
         an id to a div for example. There is no page reload this time because the stars in the first column won't change (random). 
         When clicking 'All reviews', the stars within this column will change but not the first column. When clcking 'return', this will reload the page, 
        so the stars in the first column will change and te data bellow too, since this returns to the initial state.</p>

        <p><%= link_to 'View all books with AJAX', books_ajax_path, remote: true, class:'btn btn-primary' %></p>

        <div id = "ajax-books-all"></div>  

      </div>
    </div>
  </div>   
</div>
     


<p>Books and authors can get comments by users with a polymorphic association (type <=> Book or Author, and id).
 We also have a 'User has_many :books' and 'User has_many :authors' association as a user can put many reviews which is polymorphic.  </p>
<div class="container">
  <div class="row">

    <h3>Uncommented books: using a scope and finding nil column on associated table</h3>
    <%= render 'books/reviewed_unreviewed', books: @unreviewed_books %>

  </div>
  <div class="row">

    <h3>Commented books: using a scope and simply joins</h3>
    <%= link_to 'Comment books', root_path %>
    <%#= render 'books/reviewed_unreviewed', books: @reviewed_books %>
    
  </div>
</div>



<%#= render 'books/catalog', authors: @authors %>

<!-- https://medium.com/le-wagon/build-a-simple-search-with-the-simple-form-gem-in-rails-5-b247168282d1> -->
<!-- standard method is POST so GET is specified here. -->
<!-- By using a symbol instead of an object, we can get a key in the params. Here  ':book_title' -->
<!-- so params[:search][:book_title] contains the title -->
<!-- If we had declared on object say @search, then it would have to be defined, not the case here -->

<!-- the url:'root_path', means the  result will render on the root page, so on the same page (SPA) -->
<!-- if url:'get...title_path' tells where to be displayed. It should render another page (related to the -->
<!-- view convention, but by defining the method as AJAX rendering, the Javascript will render the partial-->
<!-- where we want. This AJAX call is permitted simply by 'remote: true'  -->

<!-- 'input_field' gets rid of the div and displays the form-group elts inline. -->

<!-- we set collection here as we want the inputs to be controlled -->

<!-- with 'multiple: true', we have a drop-down selection form -->

<div class='container' id='search'>
<h3>Search forms are AJAX rendered</h3>
  <div class="row">
    <div class='col'>
      <div>
        <h5>Reviews on books</h5>
        <p>(search by title)</p>
        <%= simple_form_for :search, url: get_reviews_by_title_path, remote: true, method: "GET" do |f| %>   
          <%= f.input_field :input_title, collection: @titles, multiple: true %>
          <%= f.submit "Search", class:"btn btn-primary"%>
        <% end %>
      </div>
      
      <div id="ajax_review_by_title"> <!-- JS injection here --> </div>
    </div>


    <div class='col'>
      <div>
        <h5>Books by author</h5>
        <%= simple_form_for :search, url: get_books_by_author_path, remote: true, method: "GET" do |f| %>   
            <%= f.input_field :input_name, collection: @list_authors, multiple: true  %>
            <%= f.button :submit, "Search", class:"btn-primary" %>
        <% end %>
      </div>
      
      <div id="ajax_books_by_author"> </div>
    </div>


    <div class='col'>
      <div>
        <h5>Comments from the users</h5>
        <p>(usage of "reviewable")</p>
        <%= simple_form_for :search, url: get_reviews_by_user_path, remote: true, method: "GET" do |f| %>   
          <%= f.input_field :user_name, collection: @users_names, multiple: true %>
          <%= f.submit "Search", class:"btn btn-primary" %>
        <% end %>
      </div>

      <div id="ajax_reviews_by_user">
        <% if false && @name == nil %>
          <h3>All comments by users: usage of "reviewable"</h3>
          <%= render 'books/users_reviews', users: @users %>
        <% end %>
      </div>

    </div>
  </div>
</div>

<div class="container" id="API-JSON"></div>